import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';
import nodemailer from 'npm:nodemailer@6.9.8';

function toBool(val, fallback) {
  if (typeof val !== 'string') return !!fallback;
  const v = val.trim().toLowerCase();
  return v === 'true' || v === '1' || v === 'yes';
}

async function trySend({ host, port, secure, authUser, authPass, fromEmail, fromName, to, subject, text, html }) {
  const transporter = nodemailer.createTransport({
    host,
    port,
    secure,
    auth: { user: authUser, pass: authPass },
    // For 587 use STARTTLS
    requireTLS: !secure && port === 587,
    // Zoho works fine with LOGIN
    authMethod: 'LOGIN',
    tls: { minVersion: 'TLSv1.2' },
    // Helpful timeouts
    connectionTimeout: 15000,
    greetingTimeout: 10000,
    socketTimeout: 20000
    // logger: true, debug: true
  });

  // Verify first for clearer errors
  await transporter.verify();

  const info = await transporter.sendMail({
    from: fromName ? `"${fromName}" <${fromEmail || authUser}>` : (fromEmail || authUser),
    to,
    subject,
    text: text || undefined,
    html: html || undefined
  });

  return { messageId: info?.messageId || null, response: info?.response || null };
}

Deno.serve(async (req) => {
  try {
    const base44 = createClientFromRequest(req);
    const user = await base44.auth.me();
    if (!user) return Response.json({ error: 'Unauthorized' }, { status: 401 });

    const body = await req.json().catch(() => ({}));
    const to = body?.to;
    const subject = body?.subject || '';
    const text = body?.text || body?.body || '';
    const html = body?.html || null;
    const fromEmail = body?.from_email || Deno.env.get('SMTP_FROM_EMAIL') || '';
    const fromName = body?.from_name || Deno.env.get('SMTP_FROM_NAME') || 'Planlyze';

    if (!to) return Response.json({ error: 'Missing "to"' }, { status: 400 });
    if (!text && !html) return Response.json({ error: 'Missing email content (text or html required)' }, { status: 400 });

    const host = Deno.env.get('SMTP_HOST') || '';
    const portStr = Deno.env.get('SMTP_PORT') || '';
    const secureEnv = Deno.env.get('SMTP_SECURE') || '';
    const userEnv = Deno.env.get('SMTP_USER') || '';
    const passEnv = Deno.env.get('SMTP_PASS') || '';

    const missing = [];
    if (!host) missing.push('SMTP_HOST');
    if (!portStr) missing.push('SMTP_PORT');
    if (!userEnv) missing.push('SMTP_USER');
    if (!passEnv) missing.push('SMTP_PASS');
    if (missing.length) {
      return Response.json({ error: `SMTP not configured. Missing: ${missing.join(', ')}` }, { status: 500 });
    }

    const initialPort = Number(portStr);
    // If SMTP_SECURE isn't provided, infer from port (465 => true)
    let initialSecure = toBool(secureEnv, initialPort === 465);
    // Force Zoho recommended modes:
    // - 587 => STARTTLS (secure=false)
    // - 465 => SSL (secure=true)
    if (initialPort === 587) initialSecure = false;
    if (initialPort === 465) initialSecure = true;

    // Try the configured port first
    try {
      const res = await trySend({
        host,
        port: initialPort,
        secure: initialSecure,
        authUser: userEnv,
        authPass: passEnv,
        fromEmail,
        fromName,
        to,
        subject,
        text,
        html
      });
      return Response.json({ ok: true, tried: [{ host, port: initialPort, secure: initialSecure }], ...res });
    } catch (err1) {
      // Fallback to the alternate Zoho port/mode
      const fallbackPort = initialPort === 587 ? 465 : 587;
      const fallbackSecure = fallbackPort === 465;

      try {
        const res2 = await trySend({
          host,
          port: fallbackPort,
          secure: fallbackSecure,
          authUser: userEnv,
          authPass: passEnv,
          fromEmail,
          fromName,
          to,
          subject,
          text,
          html
        });
        return Response.json({
          ok: true,
          tried: [
            { host, port: initialPort, secure: initialSecure, error: err1?.message || String(err1) },
            { host, port: fallbackPort, secure: fallbackSecure }
          ],
          ...res2
        });
      } catch (err2) {
        // Return both attempts' errors for debugging (e.g., ECONNREFUSED/ETIMEDOUT)
        return Response.json({
          error: 'SMTP connection failed for both primary and fallback configurations',
          details: {
            primary: { host, port: initialPort, secure: initialSecure, error: err1?.message || String(err1) },
            fallback: { host, port: fallbackPort, secure: fallbackSecure, error: err2?.message || String(err2) }
          }
        }, { status: 500 });
      }
    }
  } catch (error) {
    return Response.json({ error: error?.message || 'SMTP send failed' }, { status: 500 });
  }
});